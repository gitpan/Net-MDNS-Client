/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Client.xs. Do not edit this file, edit Client.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Client.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include <netinet/in.h>
#include <../../../../mdns-wrapper/mdns_client.h>

#include "const-c.inc"

#line 22 "Client.c"

/* INCLUDE:  Including 'const-xs.inc' from 'Client.xs' */

XS(XS_Net__MDNS__Client_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__MDNS__Client_constant)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Net::MDNS::Client::constant(sv)");
    SP -= items;
    {
#line 4 "const-xs.inc"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv;
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 45 "Client.c"
	SV *	sv = ST(0);
	const char *	s = SvPV(sv, len);
#line 18 "const-xs.inc"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv = sv_2mortal(newSVpvf("%s is not a valid Net::MDNS::Client macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined Net::MDNS::Client macro %s, used", s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing Net::MDNS::Client macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 120 "Client.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Client.xs' from 'const-xs.inc' */

XS(XS_Net__MDNS__Client_cancel_query); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__MDNS__Client_cancel_query)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Net::MDNS::Client::cancel_query(query_type, query_string)");
    {
	char *	query_string = (char *)SvPV_nolen(ST(1));
	char *	query_type = (char *)SvPV_nolen(ST(0));

	mdnsc_cancel_query(query_type, query_string);
    }
    XSRETURN_EMPTY;
}

XS(XS_Net__MDNS__Client_get_a_result); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__MDNS__Client_get_a_result)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Net::MDNS::Client::get_a_result(query_type, query_string)");
    SP -= items;
    {
	char *	query_string = (char *)SvPV_nolen(ST(1));
	char *	query_type = (char *)SvPV_nolen(ST(0));
	mdnsda	RETVAL;
#line 27 "Client.xs"
		mdnsda r;
		struct in_addr in;
		char * t;

#line 160 "Client.c"
#line 32 "Client.xs"
		r = mdnsc_get_a_result(query_type, query_string);
		if ( GIMME_V == G_VOID )
			{ XSRETURN_UNDEF;}
		if (r)
			{
				if ( GIMME_V == G_SCALAR )
					{
						if (!strcmp("host by service", query_type))
                        {
													int len; char u[513]; char * p;
													p = (char *) &u;
													if ( r->rdlen >511 ) {len=511;} else {len=r->rdlen;}
													strncpy( p, (char *)(r->rdata+1), len-3);
													u[len-3]=0;
													XSRETURN_PV( p);
												}

                if (!strcmp("ip by hostname", query_type))
                        {  
													in.s_addr = r->ip;
													t = inet_ntoa(in);
													XSRETURN_PV(t);
												}

                if (!strcmp("data by hostname", query_type))
                        { XSRETURN_IV(r->srv.port);}
					}
         if ( GIMME_V == G_ARRAY )
           {
							if (r->name)
								{
									XPUSHs(sv_2mortal(newSVpv("name", 4)));
									XPUSHs(sv_2mortal(newSVpv(r->name, strlen(r->name))));
								}
							XPUSHs(sv_2mortal(newSVpv("type", 4)));
							XPUSHs(sv_2mortal(newSViv((int ) r->type)));
							XPUSHs(sv_2mortal(newSVpv("ttl", 3)));
							XPUSHs(sv_2mortal(newSViv((int ) r->ttl)));
							if (r->rdlen>2)
								{
									XPUSHs(sv_2mortal(newSVpv("rdata", 5)));
									XPUSHs(sv_2mortal(newSVpv(r->rdata, r->rdlen-2)));
								}
							XPUSHs(sv_2mortal(newSVpv("ip", 2)));
							in.s_addr = r->ip;
							t = inet_ntoa(in);
							XPUSHs(sv_2mortal(newSVpv(t, strlen(t))));
							XPUSHs(sv_2mortal(newSVpv("priority", 8)));
							XPUSHs(sv_2mortal(newSViv((int )r->srv.priority)));
							XPUSHs(sv_2mortal(newSVpv("weight", 6)));
							XPUSHs(sv_2mortal(newSViv((int )r->srv.weight)));
							XPUSHs(sv_2mortal(newSVpv("port", 4)));
							XPUSHs(sv_2mortal(newSViv((int )r->srv.port)));
					}
		}
#line 217 "Client.c"
	PUTBACK;
	return;
    }
}

XS(XS_Net__MDNS__Client_make_query); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__MDNS__Client_make_query)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: Net::MDNS::Client::make_query(query_type, hostname, service, domain, protocol)");
    {
	char *	query_type = (char *)SvPV_nolen(ST(0));
	char *	hostname = (char *)SvPV_nolen(ST(1));
	char *	service = (char *)SvPV_nolen(ST(2));
	char *	domain = (char *)SvPV_nolen(ST(3));
	char *	protocol = (char *)SvPV_nolen(ST(4));
	char *	RETVAL;
	dXSTARG;

	RETVAL = mdnsc_make_query(query_type, hostname, service, domain, protocol);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Net__MDNS__Client_process_network_events); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__MDNS__Client_process_network_events)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Net::MDNS::Client::process_network_events()");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = mdnsc_process_network_events();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Net__MDNS__Client_query); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__MDNS__Client_query)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Net::MDNS::Client::query(query_type, query_string)");
    {
	char *	query_string = (char *)SvPV_nolen(ST(1));
	char *	query_type = (char *)SvPV_nolen(ST(0));

	mdnsc_query(query_type, query_string);
    }
    XSRETURN_EMPTY;
}

XS(XS_Net__MDNS__Client_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__MDNS__Client_start)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Net::MDNS::Client::start()");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = mdnsc_start();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Net__MDNS__Client_stop); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__MDNS__Client_stop)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Net::MDNS::Client::stop()");
    {

	mdnsc_stop();
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Net__MDNS__Client); /* prototype to pass -Wmissing-prototypes */
XS(boot_Net__MDNS__Client)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("Net::MDNS::Client::constant", XS_Net__MDNS__Client_constant, file);
        newXS("Net::MDNS::Client::cancel_query", XS_Net__MDNS__Client_cancel_query, file);
        newXS("Net::MDNS::Client::get_a_result", XS_Net__MDNS__Client_get_a_result, file);
        newXS("Net::MDNS::Client::make_query", XS_Net__MDNS__Client_make_query, file);
        newXS("Net::MDNS::Client::process_network_events", XS_Net__MDNS__Client_process_network_events, file);
        newXS("Net::MDNS::Client::query", XS_Net__MDNS__Client_query, file);
        newXS("Net::MDNS::Client::start", XS_Net__MDNS__Client_start, file);
        newXS("Net::MDNS::Client::stop", XS_Net__MDNS__Client_stop, file);
    XSRETURN_YES;
}

